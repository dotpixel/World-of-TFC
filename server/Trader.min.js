/*
TraderPatch

Created By Runonstof
*/

//Convert object to array

function getObjectProp(obj, prop) {
    var objRgx = /([\w]+)(?:\[(\d+)\])?/g;
    var match;
    while ((match = objRgx.exec(prop)) !== null) {
        //handle key
        if (typeof obj[match[1]] === 'undefined') {
            return null;
        }

        obj = obj[match[1]];

        if (typeof match[2] !== 'undefined') {
            if (typeof obj[parseInt(match[2])] === 'undefined') {
                return null;
            }

            obj = obj[parseInt(match[2])];
        }
    }

    return obj
}

//Get functions in the object
function getAllFuncs(obj) {
    var props = [];

    do {
        props = props.concat(Object.getOwnPropertyNames(obj));
    } while (obj = Object.getPrototypeOf(obj));

    return props.sort().filter(function(e, i, arr) {
        if (e != arr[i + 1] && typeof obj[e] == 'function') return true;
    });
}

//Merge 2 objects
function objMerge(obj1, obj2, inheritNewProps) {
	if(typeof(inheritNewProps) == typeof(undefined) || inheritNewProps === null) { inheritNewProps = true; }
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) {
        if (inheritNewProps || Object.keys(obj1).indexOf(attrname) > -1) {
            obj3[attrname] = obj2[attrname];
        }
    }
    return obj3;
}

Object.__proto__.assign = function() {
    var obj = arguments[0];

    for (var i = 1; i < arguments.length; i++) {
        var arg = arguments[i];
        for(var key in arg) {
var value = arg[key];
            obj[key] = value;
        }
    }

    return obj;
};

Object.__proto__.values = function(obj) {
        var vals = [];
        for (var i in obj) {
            vals.push(obj[i]);
        }

        return vals;
    }
    /* */

function formatObj(obj, options, tabIndex, maxDeep, maxLoop, propTypes, propType, argFn) {
	if(typeof(propTypes) == typeof(undefined) || propTypes === null) { propTypes = {}; }
	if(typeof(argFn) == typeof(undefined) || argFn === null) { argFn = null; }
    if (typeof obj === 'object' && obj !== null && !(obj instanceof Java.type('java.lang.Object'))) {

        var tabIndex = (typeof tabIndex === 'undefined' || tabIndex == null) ? 1 : tabIndex;
        var isObjArray = isArray(obj);
        var tabs = '';
        var prevTabs = '';
        for (var i = 0; i < tabIndex; i++) {
            tabs += '  ';
            if (i < tabIndex - 1) {
                prevTabs += '  ';
            }
        }

        var str = prevTabs + '&8[\n';
        if (tabIndex <= maxDeep || maxDeep === -1 || typeof maxDeep === 'undefined') {
            var index = 0;
            for (var i in obj) {
                if (index > maxLoop && typeof maxLoop !== 'undefined' && maxLoop !== -1) {
                    str += tabs + '&e&l...\n';
                    break;
                }
                index++;
                var passPropType = propTypes[i] || null;
                var args = {
                    obj: obj,
                    tabIndex: tabIndex,
                    maxDeep: maxDeep,
                    maxLoop: maxLoop,
                    propTypes: propTypes,
                    passPropType: passPropType,
                    argFn: argFn
                };

                if (typeof argFn === 'function') {
                    argFn.apply(args);
                }

                str += tabs + (parseInt(i).toString() == i.toString() ? '&b' + i : '&c"' + i + '"') + '&7 => ' + formatObj(obj[i], options, args.tabIndex + 1, args.maxDeep, args.maxLoop, args.propTypes, args.passPropType, args.argFn) + ',\n';
            }
        } else {
            str += tabs + '&e&l...\n';
        }

        str += prevTabs + '&8]';
        return str;
    }
    // print(JSON.stringify([propTypes, propType]));
    var typeStr = '';
    switch (propType) {
        case 'money':
            obj = '&r:money:&e' + getAmountCoin(obj) + '&7';
            break;
        case 'time':
            obj = '&e' + getTimeString(obj) + '&7';
            break;
        case 'date':
            obj = '&e' + getDateString(obj) + '&7';
            break;
        default:
            
            if(options.showTypes) {
                typeStr = '&3&o&l('+(typeof obj)+')&r';
            }

            if (obj == null) {
                obj = '&6&lnull&7';
            } else if (typeof obj === 'string') {
                obj = '&a"' + obj + '"&7';
            } else if (typeof obj === 'number') {
                obj = '&e' + obj.toString() + '&7';
            } else if (typeof obj === 'boolean') {
                obj = '&3' + obj.toString() + '&7';
            } else {
                obj = obj.toString();
            }
            break;
    }

   

    return typeStr + obj;
}; /* */
var _RAWCOLORS = {
    '0': 'black',
    '1': 'dark_blue',
    '2': 'dark_green',
    '3': 'dark_aqua',
    '4': 'dark_red',
    '5': 'dark_purple',
    '6': 'gold',
    '7': 'gray',
    '8': 'dark_gray',
    '9': 'blue',
    'a': 'green',
    'b': 'aqua',
    'c': 'red',
    'd': 'light_purple',
    'e': 'yellow',
    'f': 'white',
};

var _RAWEFFECTS = {
    'o': 'italic',
    'l': 'bold',
    'k': 'magic',
    'm': 'strike',
    'n': 'underline',
    'r': 'reset'
}

var _RAWCODES = Object.keys(_RAWCOLORS).concat(Object.keys(_RAWEFFECTS));
var CHAT_EMOTES = CHAT_EMOTES || [];

function getColorId(name) {
    for (var i in _RAWCOLORS) {
        if (name == _RAWCOLORS[i]) {
            return i;
        }
    }
    for(var i in _RAWEFFECTS) {
var re = _RAWEFFECTS[i];
        if (name == re) {
            return i;
        }
    }
    return 'r';
}

function getColorName(id) {
    for(var i in _RAWCOLORS) {
var rc = _RAWCOLORS[i];
        if (id == i) {
            return rc;
        }
    }
    for(var i in _RAWEFFECTS) {
var re = _RAWEFFECTS[i];
        if (id == i) {
            return re;
        }
    }
    return 'white';
}

function stripColors(str) {
    for(var i in _RAWCODES) {
var rawcode = _RAWCODES[i];
        str = str.replaceAll('&' + rawcode, '');
    }

    return str;
}

function slugify(text) {
    text = stripColors(text);
    return text.toString().toLowerCase()
        .replace(/\s+/g, '_') // Replace spaces with -
        .replace(/[^\w\-]+/g, '') // Remove all non-word chars
        .replace(/__+/g, '_') // Replace multiple - with single -
        .replace(/^_+/, '') // Trim - from start of text
        .replace(/_+$/, ''); // Trim - from end of text
}

function ccs(str, af) {
	if(typeof(af) == typeof(undefined) || af === null) { af = null; }
    return colorCodeString(str, af);
}

function colorCodeString(str, allowed_formats) {
	if(typeof(allowed_formats) == typeof(undefined) || allowed_formats === null) { allowed_formats = null; }
    if (allowed_formats == null) {
        allowed_formats = Object.keys(_RAWCOLORS).concat(Object.keys(_RAWEFFECTS));
    }
    allowed_formats = allowed_formats.filter(function(item) { ['x', 'y'].indexOf(item) == -1; });
    return str.replace(new RegExp("&([" + allowed_formats.join("") + "])", 'g'), '\u00A7$1').replace(/&\\/g, '&');
}

function escCcs(str, esc_formats) {
	if(typeof(esc_formats) == typeof(undefined) || esc_formats === null) { esc_formats = null; }
    if (esc_formats == null) {
        esc_formats = _RAWCODES;
    }

    return str.replace(new RegExp('&([' + esc_formats.join("") + '])', 'g'), '');
}

function parseEmotes(str, allwd, replaceOld) {
	if(typeof(allwd) == typeof(undefined) || allwd === null) { allwd = []; }
	if(typeof(replaceOld) == typeof(undefined) || replaceOld === null) { replaceOld = true; }
    if (replaceOld) {
        str = str.replaceAll(Object.values(CHAT_EMOTES), '');
    }
    for (var ce in CHAT_EMOTES) {
        var chatemote = CHAT_EMOTES[ce];
        if (allwd.length == 0 || allwd.indexOf(ce) > -1) {
            str = str.replaceAll(':' + ce + ':', chatemote);
            str = str.replaceAll(':/' + ce + '/:', ':' + ce + ':');
        }
    }
    return str;
}

function strf(str, toRaw, allowed) {
	if(typeof(toRaw) == typeof(undefined) || toRaw === null) { toRaw = true; }
	if(typeof(allowed) == typeof(undefined) || allowed === null) { allowed = null; }
	return strrawformat(str, toRaw, allowed);
}
var CHAT_CMD_RGX = /{[\s]*(?:([\w]+)[\s]*\:[\s]*([\w\W\/]+?)|\*)(?:[\s]*\|[\s]*([\w]+)[\s]*\:[\s]*([\w\W\/]+?[\s]*))?}/;
var CHAT_CMD_RGX_G = /{[\s]*(?:([\w]+)[\s]*\:[\s]*([\w\W\/]+?)|\*)(?:[\s]*\|[\s]*([\w]+)[\s]*\:[\s]*([\w\W\/]+?[\s]*))?}/g;


function strrawformat(str, toRaw, allowed) {
	if(typeof(toRaw) == typeof(undefined) || toRaw === null) { toRaw = false; }
	var rf = [];
	var txt = '';
	var ri = -1;
	var isCode = false;
	var txtColor = 'white';
	var isItalic = false;
	var isBold = false;
	var isStrike = false;
	var isUnderlined = false;
	var isObf = false;
	str = str+'&r ';

	for(var i = 0; i < str.length; i++) {
		var c = str.substr(i, 1);
		if(c == '&' || i == str.length-1) {
			//Check if new section has to be made
			if(txt.length > 0) {
				ri++;
				var cmds = [];

				rf.push([txt, txtColor, isItalic, isBold, isUnderlined, isStrike, isObf]);
				isItalic = false;
				isBold = false;
				isUnderlined = false;
				isStrike = false;
				isObf = false;
				txtColor = 'white';
				txt = '';
			}
			isCode = true;
			continue;
		} else {
			if(!isCode) {
				txt += c.toString();
			} else {
				//Check Colors
				if(typeof(_RAWCOLORS[c]) != typeof(undefined)) {
					txtColor = _RAWCOLORS[c];
				}
				//Check Markup
				switch(c.toString()) {
					case 'o': {
						isItalic = true;
						break;
					}
					case 'l': {
						isBold = true;
						break;
					}
					case 'n': {
						isUnderlined = true;
						break;
					}
					case 'm': {
						isStrike = true;
						break;
					}
					case 'k': {
						isObf = true;
						break;
					}
					case 'r': {
						isItalic = false;
						isBold = false;
						isUnderlined = false;
						isStrike = false;
						isObf = false;
						txtColor = 'white';
						break;
					}
				}
				isCode = false;
			}
		}
	}

	return (!toRaw ? rf : rawformat(rf, true));
}

function rawformat(str_pieces, fullraw, allowed) {
	if(typeof(fullraw) == typeof(undefined) || fullraw === null) { fullraw = true; }
	if(typeof(allowed) == typeof(undefined) || allowed === null) { allowed = null; }
	if(allowed == null) {
		allowed = Object.keys(_RAWCOLORS).concat(Object.keys(_RAWEFFECTS)).concat(['x', 'y']);

	}
	var txt = '';
	if(fullraw) { txt+='[""'; }

	for(var i in str_pieces) {
		var p = str_pieces[i];
		var ntext = p[0].replace(/\"/g, '\\"');
		var nm =  ntext.match(CHAT_CMD_RGX) || [];
		if(nm.length > 0) {
			p[7] = nm[1];
			p[8] = nm[2];
			p[9] = nm[3];
			p[10] = nm[4];
			ntext = ntext.replace(nm[0], '');
		}
		var pc = '{"text":"'+ntext+'"';
		if(p[1]) {
			if(allowed.indexOf(getColorId(p[1])) == -1) {
				p[1] = 'white';
			}

			pc+=',"color":"'+p[1].toString()+'"';

		}
		if(p[2]) {
			if(allowed.indexOf('o') > -1) {
				pc+=',"italic":true';
			}
		}
		if(p[3]) {
			if(allowed.indexOf('l') > -1) {
				pc+=',"bold":true';
			}
		}
		if(p[4]) {
			if(allowed.indexOf('n') > -1) {
				pc+=',"underlined":true';
			}
		}
		if(p[5]) {
			if(allowed.indexOf('m') > -1) {
				pc+=',"strikethrough":true';
			}
		}
		if(p[6]) {
			if(allowed.indexOf('k') > -1) {
				pc+=',"obfuscated":true';
			}
		}

		if(p[7] && p[8]) { pc+=',"clickEvent":{"action":"'+p[7]+'","value":"'+p[8]+'"}'; }
		if(p[9] && p[10]) { pc+=',"hoverEvent":{"action":"'+p[9]+'","value":"'+ccs((p[10]||"").replace(/\$/g, '\u00A7'),allowed)+'"}'; }
		pc += '}';


		txt+=( fullraw ? ',' : '' )+pc.toString();
	}

	if(fullraw) {
		txt += ']';
	}

	return txt;
}

/**
 * 
 * @param {Number} value Current value
 * @param {Number} max Maximum value
 * @param {Number} length Character length
 * @param {String||'|'} progChar Progressbar character
 * @param {String} fillColor Filled color code '&a'
 * @param {String} leftColor Filles color code '&c'
 */
function progressBar(value, max, length, progChar, fillColor, leftColor, opener, closer){
	if(typeof(progChar) == typeof(undefined) || progChar === null) { progChar = null; }
	if(typeof(fillColor) == typeof(undefined) || fillColor === null) { fillColor = '&a'; }
	if(typeof(leftColor) == typeof(undefined) || leftColor === null) { leftColor = '&c'; }
	if(typeof(opener) == typeof(undefined) || opener === null) { opener = '&l['; }
	if(typeof(closer) == typeof(undefined) || closer === null) { closer = '&l]'; }
	var skillBar = '&r'+opener+'&r';
	var progress = Math.floor((value/max)*length);
	var proc = Math.round(value/max*100);
	for(var i = 0; i < length; i++) {
		if(i < progress) skillBar += fillColor+(progChar||'|');
		if(i >= progress) skillBar += leftColor+(progChar||'|');
	}
	return skillBar += '&r'+closer+'&r';
}

var API = Java.type('noppes.npcs.api.NpcAPI').Instance();
var INbt = Java.type('noppes.npcs.api.INbt');
var LogManager = Java.type('org.apache.logging.log4j.LogManager');
var Logger = LogManager.getLogger(typeof CONFIG_SERVER != typeof undefined ? CONFIG_SERVER.NAME : "");
var ForgeLoader = Java.type('net.minecraftforge.fml.common.Loader').instance();
var EntityType = Java.type('noppes.npcs.api.constants.EntityType');
var REGISTRY = Java.type('net.minecraftforge.fml.common.registry.ForgeRegistries');

var NbtTypes = {
    "Byte": 1,
    "Short": 2,
    "Integer": 3,
    "Long": 4,
    "Float": 5,
    "Double": 6,
    "ByteArray": 7,
    "String": 8,
    "List": 9,
    "Compound": 10,
    "IntegerArray": 11,
};

function getNbtType(num) {
    for(var n in NbtTypes) {
var nbtType = NbtTypes[n];
        if(nbtType === num) { return n; }
    }
    return null;
}

function getMCModList() {
    var modlist = [];
    var loadmods = Java.type("net.minecraftforge.fml.common.Loader").instance().getModList();

    for(var mid in loadmods) {
var lmod = loadmods[mid];
        modlist.push(lmod.getModId());
    }

    return modlist;
}

function hasMCMod(name) {
    return getMCModList().indexOf(name) > -1;
}


function executeCommand(player, command, as_player) {
	if(typeof(as_player) == typeof(undefined) || as_player === null) { as_player = null; }
	if(as_player == null) { as_player = player.getName(); }
	var cmd = API.createNPC(player.world.getMCWorld());

	return cmd.executeCommand("/execute "+as_player+" ~ ~ ~ "+command);

}

function executeCommandGlobal(command, dim) {
	if(typeof(dim) == typeof(undefined) || dim === null) { dim = 0; }
	return API.createNPC(API.getIWorld(dim).getMCWorld()).executeCommand(command);
}

//Send player formatted message
function tellPlayer(player, rawtext) {
    return executeCommand(player, "/tellraw " + player.getName() + " " + parseEmotes(strf(rawtext)));
}

function tellGlobal(target, text) {
    return executeCommandGlobal('/tellraw ' +target + ' ' + parseEmotes(strf(text)));
}

function tellTarget(player, target, rawtext) {
    return executeCommand(player, "/tellraw " + target + " " + parseEmotes(strf(rawtext)));
}

function tellPlayerTitle(player, rawtext, type, target) {
	if(typeof(type) == typeof(undefined) || type === null) { type = "actionbar"; }
    return executeCommand(player, "/title " + (target || player.getName()) + " " + type + " " + parseEmotes(strf(rawtext)))
}
//Send player multiple formatted messages from array
function storytellPlayer(player, ar) {
    for(var i in ar) {
var ari = ar[i];
        tellPlayer(player, ari);
    }
}

//Get server title bar for displaying
//TO-DO: Placeholders instead of multiple variables
function getTitleBar(title, showServerName) {
	if(typeof(showServerName) == typeof(undefined) || showServerName === null) { showServerName = true; }
    return CONFIG_SERVER.BAR_OPEN + (showServerName ? CONFIG_SERVER.TITLE + " " : CONFIG_SERVER.PREFIX) + title + CONFIG_SERVER.BAR_CLOSE;
}

function getNavBar() {
    return '&r[== &e[:sun: Menu]{run_command:!menu|show_text:$eClick to show menu or do $o!menu}&r ==]';
}

function getUndoBtn(undo_cmds, hoverText) {
	if(typeof(hoverText) == typeof(undefined) || hoverText === null) { hoverText = null; }
    return "&r[" + _MSG['undoBtnText'] + "{run_command:!chain ;" + undo_cmds.join(";") + (hoverText == null ? "" : "|show_text:" + hoverText.toString()) + "}&r]";
}
//Compare 2 IItemStacks
function isItemEqual(stack, other, ignoreNbt){
	if(typeof(ignoreNbt) == typeof(undefined) || ignoreNbt === null) { ignoreNbt = false; }
	if (!other || other.isEmpty()) {
		return false;
	}

	var stackNbt = stack.getItemNbt();
	stackNbt.remove('Count');
	var otherNbt = other.getItemNbt();
	otherNbt.remove('Count');

	if(ignoreNbt) {
		if(stackNbt.getString("id") == otherNbt.getString("id")) {
			return true;
		}
	} else {
		if(isNbtEqual(stackNbt, otherNbt)) {
			return true;
		}
	}

	return false;
}



function ENbt(nbtObject) {
    this.nbt = nbtObject; /* INbt */
    this.copy = function() {
        return new ENbt(API.stringToNbt(this.nbt.toJsonString()));
    };
    this.get = function(path) {
        var paths = path.toString().split(".");
        var cur = this.nbt;
        for(var pa in paths) {
var p = paths[pa];
            if(!cur.has(p)) {
                return null;
            }

            var keyType = getNbtType(cur.getType(p));
            if(keyType != "List") {
                //getString, getInteger etc
                cur = cur["get"+keyType](p);
            } else {
                cur = cur["get"+keyType](p, cur.getListType(p));
            }
        }
        return cur;
    };
    this.toJsonString = function() { return this.nbt.toJsonString(); }
    this.toJsonObj = function() { return JSON.parse(this.toJsonString()); }
}

function nbtCopy(nbt) {
	return API.stringToNbt(nbt.toJsonString());
}

function nbtToObject(nbt) {
    return nbt.toJsonString().replace(/"([\w:]+?)": (\d)\w/g, '"$1": $2');
}

function nbtItem(nbt, w) {
	if(typeof(nbt) == 'string') { nbt = API.stringToNbt(nbt); }
	var item = w.createItemFromNbt(nbt);
	return item;
}

function nbtGetList(nbt, list) {
    return (nbt.has(list) ? nbt.getList(list, nbt.getListType(list)) : null);
}

//Turn String[] with item nbts to IItemStack[]
function nbtItemArr(nbtArr, w) {
    var itemArr = [];
	for(var itemData in nbtArr) {
var item = nbtArr[itemData];
        itemArr.push(nbtItem(item, w));
    }

    return itemArr;
}

function isNbtEqual(nbt, otherNbt) {
    return nbt.toJsonString() == otherNbt.toJsonString();
}

function nbtHasSameData(nbt, onbt) {
    //TODO:compare keys of nbt
}

function givePlayerItems(player, stacks, pnbt) {
	if(typeof(pnbt) == typeof(undefined) || pnbt === null) { pnbt = null; }
    var w = player.world;
    if (pnbt == null) {
        pnbt = player.getEntityNbt(); //Dont over-use this one
    }
    var invcnt = getPlayerInvCount(pnbt, w);
    for(var s in stacks) {
var stack = stacks[s];
        if (invcnt < 36) {
            //Player inv not full
            player.giveItem(stack);
            invcnt++;
        } else {
            player.dropItem(stack);
        }
    }
}

//Made for givePlayerItems (does not include armor and offhand)
function getPlayerInvCount(pnbt, w) {
    return getPlayerInvFromNbt(pnbt, w, function(item, itnbt) {
        //Exclude armor slots and offhand
        return ["-106", "100", "101", "102", "103"].indexOf(itnbt.getByte('Slot').toString()) == -1;
    }).length;
}

function getArrItemCount(array, itemstack, ignoreNbt) {
	if(typeof(ignoreNbt) == typeof(undefined) || ignoreNbt === null) { ignoreNbt = false; }
    var icount = 0;
    for(var pi in array) {
var pitem = array[pi];
        var pinbt = pitem.getItemNbt();
        var scount = parseInt(pinbt.getByte('Count'));
        if (isItemEqual(itemstack, pitem, ignoreNbt))
            icount += scount;
    }

    return icount;
}

function getPlayerInvFromNbt(pnbt, w, filterFn) {
	if(typeof(filterFn) == typeof(undefined) || filterFn === null) { filterFn = null; }
    var pinv = pnbt.getList('Inventory', pnbt.getListType('Inventory'));
    var pitems = [];
    for(var p in pinv) {
var pin = pinv[p];
        var pitm = w.createItemFromNbt(API.stringToNbt(pin.toJsonString()));
        //pin (INbt) contains key "Slot"
        //pitm.getItemNbt() does not, thats why pin is passed
        if ((filterFn == null ? true : filterFn(pitm, pin, w))) {
            pitems.push(pitm);
        }
    }

    return pitems;
}

function getInvItemCount(pnbt, itemstack, w, ignoreNbt) {
    return getArrItemCount(getPlayerInvFromNbt(pnbt, w), itemstack, ignoreNbt);
}

function playerIsOnline(world, player) {
    var isOnline = false;
    var pl = world.getAllPlayers();
    for (var p in pl) {
        if (pl[p].getName() == player.toString()) {
            isOnline = true;
            break;
        }
    }
    return isOnline;
}

function getChatMessage(player, team, color, message) {
    //time
    var curTimeStr = new Date().toLocaleTimeString("fr-FR").split(":");
    curTimeStr.pop();
    curTimeStr = curTimeStr.join(":");
    var ccode = getColorId(color);
    return "[" + curTimeStr + "] &l&" + ccode + "[&" + ccode + team + "&r &" + ccode + player + "&l&" + ccode + "] -> &r" + message;
}

function getChatTag(player, team, color) {
    var ccode = getColorId(color);
    return "&" + ccode + "&l[&" + ccode + "&o" + team + "&r &" + ccode + player + "&" + ccode + "&l]";
}

function scanPlayerOnNbt(player, nbtstring) {
    return player.getEntityNbt().getCompound('Inventory').toJsonString().indexOf(nbtstring.toString()) > -1;
}
//

function init(e) {
    

    var display = e.npc.display;
    var ai = e.npc.ai;

    // ai.setReturnsToHome(false);

}

function load(e) {
    
}

function interact(e) {
    //
    
    //
    if (e.npc.getRole().getType() == 1 && e.player.getGamemode() == 1) {
        tellPlayer(e.player, "&cYou cannot trade with this trader in creative mode! &4[Why?]{*|show_text:$cThis is an patched trader to work with items from mods like $c$oAnimania$r$c and $c$oHarvestCraft$r$c and adds more functionalities to traders. Those functionalities don't work to well if player is in creative}&r");
        e.setCanceled(true);
    }
}

function timer(e) {
    
}

function tick(e) {
    
}

function collide(e) {
    
}

function damaged(e) {
    
}

function died(e) {
    
}

function kill(e) {
    
}

function meleeAttack(e) {
    
}

function rangedAttack(e) {
    
}

function target(e) {
    
}

function targetLost(e) {
    
}

function role(e) {
    
    var w = e.player.world;
    var pnbt = e.player.getEntityNbt();
    var npcnbt = e.npc.getEntityNbt();

    var tradeIgnoreNbt = (parseInt(npcnbt.getByte('TraderIgnoreNBT')) == 1);
    var role = e.npc.getRole();
    if (role.getType() == 1) {
        if (e.isCancelable()) {
            if (e.sold != null) {
                var inv = e.player.getInventory();
                var invItems = getPlayerInvFromNbt(pnbt, w, function(item, itnbt) {
                    //Exclude armor slots and offhand
                    return ["-106", "100", "101", "102", "103"].indexOf(itnbt.getByte('Slot').toString()) == -1;
                }).length;

                if (invItems == 36) {
                    tellPlayer(e.player, "&cYou can't trade, because your inventory is full. &4[Why?]{*|show_text:$cThis is a patched trader and this is to prevent an exploit.}&r");
                    e.setCanceled(true);
                    return false;
                }


                var canTrade = true;
                var currency = [
                    e.currency1,
                    e.currency2,
                ];

                for(var c in currency) {
var crncy = currency[c];
                    if (crncy != null) {
                        var reqamount = crncy.getStackSize();
                        if (getInvItemCount(pnbt, crncy, w, tradeIgnoreNbt) < reqamount) {
                            canTrade = false;
                        }
                    }
                }

                if (canTrade) {
                    for(var c in currency) {
var crncy = currency[c];
                        if (crncy != null) {
                            e.player.removeItem(crncy, crncy.getStackSize());
                        }
                    }
                    e.player.giveItem(e.sold);
                }

                e.setCanceled(true);
            }
        }
    }
}